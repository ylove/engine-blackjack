{"version":3,"sources":["webpack:///webpack/bootstrap 2718597d5c930be06dd9","webpack:///./src/constants.js","webpack:///./src/actions.js","webpack:///./src/engine.js","webpack:///./src/presets.js","webpack:///external \"52-deck\"","webpack:///./src/index.js","webpack:///./src/game.js","webpack:///./src/paytables/luchyLuchy.js"],"names":["INVALID","RESTORE","DEAL","INSURANCE","SPLIT","HIT","DOUBLE","STAND","SURRENDER","SHOWDOWN","DEALER_HIT","RIGHT","LEFT","STAGE_READY","STAGE_PLAYER_TURN_RIGHT","STAGE_PLAYER_TURN_LEFT","STAGE_SHOWDOWN","STAGE_DEALER_TURN","STAGE_DONE","TYPES","invalid","type","payload","action","info","restore","deal","bet","sideBets","luckyLucky","insurance","split","hit","position","double","stand","surrender","showdown","dealerHoleCardOnly","dealerHit","dealerHoleCard","isNull","obj","isUndefined","isNullOrUndef","calculate","array","value","hi","lo","x","aces","memo","getHigherValidValue","handValue","checkForBusted","isBlackjack","isSoftHand","isSuited","suite","countCards","systems","getHandInfo","hasSplit","hasBlackjack","hasBusted","isClosed","canSplit","playerCards","canInsure","dealerCards","availableActions","getHandInfoAfterDeal","hand","close","playerHasBlackjack","getHandInfoAfterSplit","getHandInfoAfterHit","getHandInfoAfterDouble","initialBet","getHandInfoAfterStand","getHandInfoAfterSurrender","getHandInfoAfterInsurance","isLuckyLucky","v1","v2","v3","v4","getLuckyLuckyMultiplier","cards","isSameSuite","flatCards","isPerfectPairs","getSideBetsInfo","sideBetsInfo","perfectPairs","availableBets","multiplier","isActionAllowed","actionName","getPrize","higherValidDealerValue","dealerHasBlackjack","higherValidPlayerValue","getPrizes","history","handInfo","left","right","finalBet","wonOnRight","wonOnLeft","deck","require","Number","number","range","max","buffer","crypto","getDefaultSideBets","active","MatchTheDealer","getRules","decks","standOnSoft17","doubleAfterSplit","showdownAfterAceSplit","defaultState","hits","finalWin","stage","rules","dealerHasBusted","constants","engine","presets","actions","Game","appendEpoch","ts","state","initialState","Object","playerValue","isLeft","historyHasSplit","whiteList","dealerValue","historyItem","cardCount","insuranceValue","isFirstCardAce","insurancePrize","win","playerCardsLeftPosition","playerCardsRightPosition","forceShowdown","cardRight","cardLeft","card","objCards","checkLeftStatus","check1","check2","key","suited"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2718597d5c930be06dd9","// @flow\n/*!\n * engine-blackjack\n * Copyright(c) 2016 Marco Casula\n * GPL 2.0 Licensed\n */\n\nexport const INVALID: string = 'INVALID'\nexport const RESTORE: string = 'RESTORE'\nexport const DEAL: string = 'DEAL'\nexport const INSURANCE: string = 'INSURANCE'\nexport const SPLIT: string = 'SPLIT'\nexport const HIT: string = 'HIT'\nexport const DOUBLE: string = 'DOUBLE'\nexport const STAND: string = 'STAND'\nexport const SURRENDER: string = 'SURRENDER'\nexport const SHOWDOWN: string = 'SHOWDOWN'\nexport const DEALER_HIT: string = 'DEALER-HIT'\nexport const RIGHT: string = 'right'\nexport const LEFT: string = 'left'\nexport const STAGE_READY: string = 'ready'\nexport const STAGE_PLAYER_TURN_RIGHT: string = 'player-turn-right'\nexport const STAGE_PLAYER_TURN_LEFT: string = 'player-turn-left'\nexport const STAGE_SHOWDOWN: string = 'showdown'\nexport const STAGE_DEALER_TURN: string = 'dealer-turn'\nexport const STAGE_DONE: string = 'done'\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\nimport * as TYPES from './constants'\nimport type { Action, Card } from './types'\n\nexport const invalid = (action: Action, info: any): Action => {\n  return {\n    type: TYPES.INVALID,\n    payload: {\n      type: action.type,\n      payload: action.payload,\n      info: info\n    }\n  }\n}\n\nexport const restore = (): Action => {\n  return {\n    type: TYPES.RESTORE\n  }\n}\n\nexport const deal = ({ bet = 10, sideBets = { luckyLucky: 0 } }: { bet: number, sideBets: any } = {}): Action => {\n  return {\n    type: TYPES.DEAL,\n    payload: {\n      bet,\n      sideBets\n    }\n  }\n}\n\nexport const insurance = ({ bet = 0 }: { bet: number }): Action => {\n  return {\n    type: TYPES.INSURANCE,\n    payload: {\n      bet\n    }\n  }\n}\n\nexport const split = (): Action => {\n  return {\n    type: TYPES.SPLIT\n  }\n}\n\nexport const hit = ({ position = 'right' }: { position: string }): Action => {\n  return {\n    type: TYPES.HIT,\n    payload: {\n      position\n    }\n  }\n}\n\nexport const double = ({ position = 'right' }: { position: string }): Action => {\n  return {\n    type: TYPES.DOUBLE,\n    payload: {\n      position\n    }\n  }\n}\n\nexport const stand = ({ position = 'right' }: { position: string }): Action => {\n  return {\n    type: TYPES.STAND,\n    payload: {\n      position\n    }\n  }\n}\n\nexport const surrender = (): Action => {\n  return {\n    type: TYPES.SURRENDER\n  }\n}\n\nexport const showdown = ({ dealerHoleCardOnly = false }: { dealerHoleCardOnly: boolean } = { }): Action => {\n  return {\n    type: TYPES.SHOWDOWN,\n    payload: {\n      dealerHoleCardOnly\n    }\n  }\n}\n\nexport const dealerHit = ({ dealerHoleCard }: { dealerHoleCard: Card } = { }): Action => {\n  return {\n    type: TYPES.DEALER_HIT,\n    payload: {\n      dealerHoleCard\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\nimport luckyLucky from './paytables/luchyLuchy'\nimport * as TYPES from './constants'\nimport type { SideBets, Card, Hand, HandInfo, HandValue } from './types'\n\nexport const isNull = (obj: ?any): boolean => obj === null\n\nexport const isUndefined = (obj: ?any): boolean => obj === undefined\n\nexport const isNullOrUndef = (obj: ?any): boolean => isUndefined(obj) || isNull(obj)\n\nexport const calculate = (array: Array<Card>): HandValue => {\n  if (array.length === 1) {\n    if (isNullOrUndef(array[0])) {\n      return null\n    }\n    const value = array[0].value\n    return {\n      hi: value === 1 ? 11 : value,\n      lo: value === 1 ? 1 : value\n    }\n  }\n  const aces = []\n  const value = array.reduce((memo, x) => {\n    if (x.value === 1) {\n      aces.push(1)\n      return memo\n    }\n    memo += x.value\n    return memo\n  }, 0)\n  return aces.reduce((memo) => {\n    if ((memo.hi + 11) <= 21) {\n      memo.hi += 11\n      memo.lo += 1\n    } else {\n      memo.hi += 1\n      memo.lo += 1\n    }\n    if (memo.hi > 21 && memo.lo <= 21) {\n      memo.hi = memo.lo\n    }\n    return memo\n  }, {\n    hi: value,\n    lo: value\n  })\n}\n\nexport const getHigherValidValue = (handValue: HandValue):number => handValue.hi <= 21 ? handValue.hi : handValue.lo\n\nexport const checkForBusted = (handValue: HandValue): boolean => (handValue.hi > 21) && (handValue.lo === handValue.hi)\n\nexport const isBlackjack = (array: Array<Card>): boolean => array.length === 2 && calculate(array).hi === 21\n\nexport const isSoftHand = (array: Array<Card>): boolean => {\n  return array.some(x => x.value === 1) &&\n    array\n      .reduce((memo, x) => {\n        memo += (x.value === 1 && memo < 11) ? 11 : x.value\n        return memo\n      }, 0) === 17\n}\n\nexport const isSuited = (array: Array<Card> = []): boolean => {\n  if (array.length === 0) {\n    return false\n  }\n  const suite = array[0].suite\n  return array.every(x => x.suite === suite)\n}\n\nexport const countCards = (array: Array<Card>) => {\n  const systems = {\n    'Hi-Lo': [ -1, 1, 1, 1, 1, 1, 0, 0, 0, -1, -1, -1, -1 ]\n  }\n  return array.reduce((memo, x) => {\n    memo += systems['Hi-Lo'][x.value - 1]\n    return memo\n  }, 0)\n}\n\nexport const getHandInfo = (playerCards: Array<Card>, dealerCards: Array<Card>, hasSplit:boolean = false): Hand => {\n  const handValue = calculate(playerCards)\n  if (!handValue) {\n    return null\n  }\n  const hasBlackjack = isBlackjack(playerCards) && hasSplit === false\n  const hasBusted = checkForBusted(handValue)\n  const isClosed = hasBusted || hasBlackjack || handValue.hi === 21\n  const canDoubleDown = !isClosed && true\n  const canSplit = playerCards.length > 1 && playerCards[ 0 ].value === playerCards[ 1 ].value && !isClosed\n  const canInsure = dealerCards[ 0 ].value === 1 && !isClosed\n  return {\n    cards: playerCards,\n    playerValue: handValue,\n    playerHasBlackjack: hasBlackjack,\n    playerHasBusted: hasBusted,\n    playerHasSurrendered: false,\n    close: isClosed,\n    availableActions: {\n      double: canDoubleDown,\n      split: canSplit,\n      insurance: canInsure,\n      hit: !isClosed,\n      stand: !isClosed,\n      surrender: !isClosed\n    }\n  }\n}\n\nexport const getHandInfoAfterDeal = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards)\n  hand.bet = initialBet\n  // After deal, even if we got a blackjack the hand cannot be considered closed.\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    stand: true,\n    hit: true,\n    surrender: true\n  }\n  return {\n    ...hand,\n    close: hand.playerHasBlackjack\n  }\n}\n\nexport const getHandInfoAfterSplit = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards, true)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    split: false,\n    double: !hand.close && (playerCards.length === 2),\n    insurance: false,\n    surrender: false\n  }\n  hand.bet = initialBet\n  return hand\n}\n\nexport const getHandInfoAfterHit = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number, hasSplit: boolean): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards, hasSplit)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    double: (playerCards.length === 2),\n    split: false,\n    insurance: false,\n    surrender: false\n  }\n  hand.bet = initialBet\n  return hand\n}\n\nexport const getHandInfoAfterDouble = (playerCards: Array<Card>, dealerCards: Array<Card>, initialBet: number, hasSplit: boolean): Hand => {\n  const hand = getHandInfoAfterHit(playerCards, dealerCards, initialBet, hasSplit)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    hit: false,\n    stand: false\n  }\n  hand.bet = initialBet * 2\n  return {\n    ...hand,\n    close: true\n  }\n}\n\nexport const getHandInfoAfterStand = (handInfo: Hand): Hand => {\n  return {\n    ...handInfo,\n    close: true,\n    availableActions: {\n      double: false,\n      split: false,\n      insurance: false,\n      hit: false,\n      stand: false,\n      surrender: false\n    }\n  }\n}\n\nexport const getHandInfoAfterSurrender = (handInfo: Hand): Hand => {\n  const hand = getHandInfoAfterStand(handInfo)\n  return {\n    ...hand,\n    playerHasSurrendered: true,\n    close: true\n  }\n}\n\nexport const getHandInfoAfterInsurance = (playerCards: Array<Card>, dealerCards: Array<Card>): Hand => {\n  const hand = getHandInfo(playerCards, dealerCards)\n  const availableActions = hand.availableActions\n  hand.availableActions = {\n    ...availableActions,\n    stand: true,\n    hit: true,\n    surrender: true,\n    insurance: false\n  }\n  return {\n    ...hand,\n    close: hand.playerHasBlackjack\n  }\n}\n\nexport const isLuckyLucky = (playerCards: Array<Card>, dealerCards: Array<Card>): boolean => {\n  // Player hand and dealer's up card sum to 19, 20, or 21 (\"Lucky Lucky\")\n  const v1 = calculate(playerCards).hi + calculate(dealerCards).hi\n  const v2 = calculate(playerCards).lo + calculate(dealerCards).lo\n  const v3 = calculate(playerCards).hi + calculate(dealerCards).lo\n  const v4 = calculate(playerCards).lo + calculate(dealerCards).hi\n  return (v1 >= 19 && v1 <= 21) || (v2 >= 19 && v2 <= 21) || (v3 >= 19 && v3 <= 21) || (v4 >= 19 && v4 <= 21)\n}\n\nexport const getLuckyLuckyMultiplier = (playerCards: Array<Card>, dealerCards: Array<Card>) => {\n  const cards = [].concat(playerCards, dealerCards)\n  const isSameSuite = isSuited(cards)\n  const flatCards = cards.map(x => x.value).join('')\n  const value = calculate(cards)\n  return luckyLucky(flatCards, isSameSuite, value)\n}\n\nexport const isPerfectPairs = (playerCards: Array<Card>): boolean => playerCards[0].value === playerCards[1].value\n\nexport const getSideBetsInfo = (availableBets: SideBets, sideBets: SideBets, playerCards: Array<Card>, dealerCards: Array<Card>): any => {\n  const sideBetsInfo = {\n    luckyLucky: 0,\n    perfectPairs: 0\n  }\n  if (availableBets.luckyLucky && sideBets.luckyLucky && isLuckyLucky(playerCards, dealerCards)) {\n    const multiplier = getLuckyLuckyMultiplier(playerCards, dealerCards)\n    sideBetsInfo.luckyLucky = sideBets.luckyLucky * multiplier\n  }\n  if (availableBets.perfectPairs && sideBets.perfectPairs && isPerfectPairs(playerCards)) {\n    // TODO: impl colored pairs\n    // TODO: impl mixed pairs\n    sideBetsInfo.perfectPairs = sideBets.perfectPairs * 5\n  }\n  return sideBetsInfo\n}\n\nexport const isActionAllowed = (actionName: string, stage: string): boolean => {\n  if (actionName === TYPES.RESTORE) {\n    return true\n  }\n  switch (stage) {\n    case TYPES.STAGE_READY: {\n      return [TYPES.RESTORE, TYPES.DEAL].indexOf(actionName) > -1\n    }\n    case TYPES.STAGE_PLAYER_TURN_RIGHT: {\n      return [TYPES.STAND, TYPES.INSURANCE, TYPES.SURRENDER, TYPES.SPLIT, TYPES.HIT, TYPES.DOUBLE].indexOf(actionName) > -1\n    }\n    case TYPES.STAGE_PLAYER_TURN_LEFT: {\n      return [TYPES.STAND, TYPES.HIT, TYPES.DOUBLE].indexOf(actionName) > -1\n    }\n    case TYPES.SHOWDOWN: {\n      return [TYPES.SHOWDOWN, TYPES.STAND].indexOf(actionName) > -1\n    }\n    case TYPES.STAGE_DEALER_TURN: {\n      return [TYPES.DEALER_HIT].indexOf(actionName) > -1\n    }\n    default: {\n      return false\n    }\n  }\n}\n\nexport const getPrize = (playerHand: Hand, dealerCards: Array<Card>): number => {\n  const {\n    close = false,\n    playerHasSurrendered = true,\n    playerHasBlackjack = false,\n    playerHasBusted = true,\n    playerValue = {},\n    bet = 0\n  } = playerHand\n  const higherValidDealerValue = getHigherValidValue(calculate(dealerCards))\n  const dealerHasBlackjack = isBlackjack(dealerCards)\n  if (!close) {\n    return 0\n  }\n  if (playerHasBusted) {\n    return 0\n  }\n  if (playerHasSurrendered) {\n    return bet / 2\n  }\n  if (playerHasBlackjack && !dealerHasBlackjack) {\n    return bet + (bet * 1.5)\n  }\n  const dealerHasBusted = higherValidDealerValue > 21\n  if (dealerHasBusted) {\n    return (bet + bet)\n  }\n  const higherValidPlayerValue = getHigherValidValue(playerValue)\n  if (higherValidPlayerValue > higherValidDealerValue) {\n    return (bet + bet)\n  } else if (higherValidPlayerValue === higherValidDealerValue) {\n    return bet\n  }\n  return 0\n}\n\nexport const getPrizes = ({ history, handInfo: { left, right }, dealerCards }: { history: Array<any>, handInfo: HandInfo, dealerCards: Array<Card>}) => {\n  const finalBet = history.reduce((memo, x) => {\n    memo += x.value\n    return memo\n  }, 0)\n  const wonOnRight = getPrize(right, dealerCards)\n  const wonOnLeft = getPrize(left, dealerCards)\n  return {\n    finalBet: finalBet,\n    wonOnRight: wonOnRight,\n    wonOnLeft: wonOnLeft\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/engine.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\nimport * as TYPES from './constants'\n// import { shuffle, newDecks } from '52-deck'\nconst deck = require('52-deck');\ndeck.getRandom = (min, max) => {\n  let number\n  const range = max - min + 1\n  do\n  {\n    const buffer = crypto.randomBytes(4)\n    number = buffer.readUInt8(0)\n  }\n  while (number >= Number.MAX_VALUE - (Number.MAX_VALUE % range))\n  number %= range\n  return number + min\n};\nimport { shuffle, newDecks } from '52-deck'\nimport type { SideBets, Rule, State } from './types'\n\nexport const getDefaultSideBets = (active: boolean = false) : SideBets => {\n  return {\n    luckyLucky: active,\n    perfectPairs: active,\n    royalMatch: active,\n    luckyLadies: active,\n    inBet: active,\n    MatchTheDealer: active\n  }\n}\n\nexport const getRules = ({\n  decks = 1,\n  standOnSoft17 = true,\n  double = 'any',\n  split = true,\n  doubleAfterSplit = true,\n  surrender = true,\n  insurance = true,\n  showdownAfterAceSplit = true\n}: Rule) => {\n  return {\n    decks: decks || 1,\n    standOnSoft17: standOnSoft17,\n    double: double,\n    split: split,\n    doubleAfterSplit: doubleAfterSplit,\n    surrender: surrender,\n    insurance: insurance,\n    showdownAfterAceSplit: showdownAfterAceSplit\n  }\n}\n\nexport const defaultState = (rules: Rule) : State => {\n  return {\n    hits: 0,\n    initialBet: 0,\n    finalBet: 0,\n    finalWin: 0,\n    wonOnRight: 0,\n    wonOnLeft: 0,\n    stage: TYPES.STAGE_READY,\n    deck: shuffle(newDecks(rules.decks)),\n    handInfo: {\n      left: {},\n      right: {}\n    },\n    history: [],\n    availableBets: getDefaultSideBets(true),\n    sideBetsInfo: {},\n    rules: rules,\n    dealerHoleCard: null,\n    dealerHasBlackjack: false,\n    dealerHasBusted: false\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/presets.js","module.exports = require(\"52-deck\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"52-deck\"\n// module id = 4\n// module chunks = 0","// @flow\n/*!\n * engine-blackjack\n * Copyright(c) 2016 Marco Casula\n * GPL 2.0 Licensed\n */\n\n'use strict'\nimport * as constants from './constants'\nimport * as engine from './engine'\nimport * as presets from './presets'\nimport * as actions from './actions'\nimport Game from './game'\n\nexport {\n  constants,\n  engine,\n  presets,\n  actions,\n  Game\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// @flow\n/*!\n engine-blackjack\n Copyright (C) 2016 Marco Casula\n\n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2 of the License.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License along\n with this program; if not, write to the Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\nimport * as TYPES from './constants'\nimport * as engine from './engine'\nimport type { Action, State, Hand, HandValue, Rule } from './types'\nimport { defaultState, getDefaultSideBets, getRules } from './presets'\nconst actions = require('./actions')\n\nconst appendEpoch = (obj) => {\n  const { payload = { bet: 0 } } = obj\n  return Object.assign(\n    {},\n    obj,\n    {\n      value: payload.bet || 0,\n      ts: new Date().getTime()\n    }\n  )\n}\n\nexport default class Game {\n  state: State = {}\n  dispatch: Function\n  _dispatch: Function\n  getState: Function\n  setState: Function\n  enforceRules: Function\n  constructor (initialState: State, rules: Rule = getRules({})) {\n    this.state = initialState ? Object.assign({}, initialState) : defaultState(rules)\n    this.dispatch = this.dispatch.bind(this)\n    this.getState = this.getState.bind(this)\n    this.setState = this.setState.bind(this)\n    this.enforceRules = this.enforceRules.bind(this)\n    this._dispatch = this._dispatch.bind(this)\n  }\n\n  canDouble (double: string, playerValue: HandValue): boolean {\n    if (double === 'none') {\n      return false\n    } else if (double === '9or10') {\n      return ((playerValue.hi === 9) || (playerValue.hi === 10))\n    } else if (double === '9or10or11') {\n      return ((playerValue.hi >= 9) && (playerValue.hi <= 11))\n    } else if (double === '9thru15') {\n      return ((playerValue.hi >= 9) && (playerValue.hi <= 15))\n    } else {\n      return true\n    }\n  }\n\n  enforceRules (handInfo: Hand): Hand {\n    const { availableActions } = handInfo\n    const { playerValue } = handInfo\n    const { rules, history } = this.state\n    if (!this.canDouble(rules.double, playerValue)) {\n      availableActions.double = false\n    }\n    if (!rules.split) {\n      availableActions.split = false\n    }\n    if (!rules.surrender) {\n      availableActions.surrender = false\n    }\n    if (!rules.doubleAfterSplit) {\n      if (history.some(x => x.type === TYPES.SPLIT)) {\n        availableActions.double = false\n      }\n    }\n    if (!rules.insurance) {\n      availableActions.insurance = false\n    }\n    return handInfo\n  }\n\n  getState () : State {\n    return {\n      ...this.state\n    }\n  }\n\n  setState (state: State): void {\n    this.state = {\n      ...this.state,\n      ...state\n    }\n  }\n\n  dispatch (action: Action): State {\n    const { stage, handInfo, history } = this.state\n    const { type, payload = {} } = action\n    const { position = TYPES.RIGHT } = payload\n    const isLeft = position === TYPES.LEFT\n    const historyHasSplit = history.some(x => x.type === TYPES.SPLIT)\n    const hand = handInfo[position]\n\n    let isActionAllowed = engine.isActionAllowed(type, stage)\n\n    if (!isActionAllowed) {\n      return this._dispatch(actions.invalid(action, `${type} is not allowed when stage is ${stage}`))\n    }\n\n    const whiteList = [TYPES.RESTORE, TYPES.DEAL, TYPES.SHOWDOWN]\n\n    if (isActionAllowed && whiteList.some(x => x === type)) {\n      // this is a safe action. We do not need to check the status of the stage\n      // so we return the result now!\n      if (type === TYPES.DEAL && typeof payload.bet !== 'number') {\n        return this._dispatch(actions.invalid(action, `${type} without bet value on stage ${stage}`))\n      }\n      return this._dispatch(action)\n    }\n\n    if (hand.close) {\n      // TODO: consolidate this one, probably is just enough to consider the availableActions (see more below)\n      return this._dispatch(actions.invalid(action, `${type} is not allowed because \"${position}\" side of the table is closed on \"${stage}\"`))\n    }\n\n    if (isLeft && !historyHasSplit) {\n      // You want to do something on \"left\" but no split found in history.\n      // default side is \"right\". When an action want to edit the \"left\" side of the table\n      // a valid split should be appear in the history. If not, \"left\" position is not ready to be changed\n      if (!history.some(x => x.type === TYPES.SPLIT)) {\n        return this._dispatch(actions.invalid(action, `${type} is not allowed because there is no SPLIT in current stage \"${stage}\"`))\n      }\n    }\n\n    if (isLeft && !handInfo.right.close) {\n      // You want to do something on \"left\" but \"right\" is still open\n      return this._dispatch(actions.invalid(action, `${type} is not allowed because you need to finish \"left\" hand \"${stage}\"`))\n    }\n\n    if (!hand.availableActions[type.toLowerCase()]) {\n      return this._dispatch(actions.invalid(action, `${type} is not currently allowed on position \"${position}\". Stage is \"${stage}\"`))\n    }\n\n    return this._dispatch(action)\n  }\n\n  _dispatch (action: Action): State {\n    switch (action.type) {\n      case TYPES.DEAL: {\n        const { bet, sideBets } = action.payload\n        const { rules: { insurance }, availableBets, history, hits } = this.state\n        const playerCards = this.state.deck.splice(this.state.deck.length - 2, 2)\n        const dealerCards = this.state.deck.splice(this.state.deck.length - 1, 1)\n        const dealerHoleCard = this.state.deck.splice(this.state.deck.length - 1, 1)[ 0 ]\n        const dealerValue = engine.calculate(dealerCards)\n        let dealerHasBlackjack = engine.isBlackjack(dealerCards.concat([dealerHoleCard]))\n        const right = this.enforceRules(engine.getHandInfoAfterDeal(playerCards, dealerCards, bet))\n        if (insurance && dealerValue.lo === 1) {\n          dealerHasBlackjack = false\n          right.availableActions = {\n            ...right.availableActions,\n            stand: false,\n            double: false,\n            hit: false,\n            split: false,\n            surrender: false\n          }\n        }\n        const sideBetsInfo = engine.getSideBetsInfo(availableBets, sideBets, playerCards, dealerCards)\n        const historyItem = appendEpoch({\n          ...action,\n          right: playerCards,\n          dealerCards\n        })\n        this.setState({\n          initialBet: bet,\n          stage: TYPES.STAGE_PLAYER_TURN_RIGHT,\n          dealerCards: dealerCards,\n          dealerHoleCard: dealerHoleCard,\n          dealerValue: dealerValue,\n          dealerHasBlackjack: dealerHasBlackjack,\n          deck: this.state.deck.filter(x => dealerCards\n              .concat(playerCards)\n              .indexOf(x) === -1),\n          cardCount: engine.countCards(playerCards.concat(dealerCards)),\n          handInfo: {\n            left: {},\n            right\n          },\n          sideBetsInfo: sideBetsInfo,\n          availableBets: getDefaultSideBets(false),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n\n        if (right.playerHasBlackjack) {\n          // purpose of the game archived !!!\n          this._dispatch(actions.showdown())\n          break\n        }\n        if (dealerHasBlackjack) {\n          if (!right.availableActions.insurance) {\n            // nothing left, let's go and tell the customer he loses this game\n            this._dispatch(actions.showdown())\n          }\n        // else\n        // in this case, the game must continue in \"player-turn-right\"\n        // waiting for the insurance action\n        }\n        break\n      }\n      case TYPES.INSURANCE: {\n        const { bet = 0 } = action.payload\n        const { sideBetsInfo, handInfo, dealerCards, dealerHoleCard, initialBet, history, hits } = this.state\n        const dealerHasBlackjack = engine.isBlackjack(dealerCards.concat([dealerHoleCard]))\n        const insuranceValue = bet > 0 ? initialBet / 2 : 0\n        const isFirstCardAce = dealerCards[0].value === 1\n        const insurancePrize = (isFirstCardAce && dealerHasBlackjack && insuranceValue > 0 && bet > 0) ? insuranceValue * 3 : 0\n        const right = this.enforceRules(engine.getHandInfoAfterInsurance(handInfo.right.cards, dealerCards))\n        right.bet = initialBet\n        right.close = dealerHasBlackjack\n        const historyItem = appendEpoch({\n          ...action,\n          payload: { bet: insuranceValue || 0 }\n        })\n        this.setState({\n          handInfo: { left: {}, right },\n          history: history.concat(historyItem),\n          hits: hits + 1,\n          sideBetsInfo: {\n            ...sideBetsInfo,\n            insurance: {\n              risk: insuranceValue,\n              win: insurancePrize\n            }\n          }\n        })\n        if (dealerHasBlackjack) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.SPLIT: {\n        const { rules, initialBet, handInfo, dealerCards, history, hits } = this.state\n        let deck = this.state.deck\n        const playerCardsLeftPosition = [handInfo.right.cards[ 0 ]]\n        const playerCardsRightPosition = [handInfo.right.cards[ 1 ]]\n        const forceShowdown = rules.showdownAfterAceSplit && playerCardsRightPosition[ 0 ].value === 1\n        let cardRight = deck.splice(deck.length - 2, 1)\n        let cardLeft = deck.splice(deck.length - 1, 1)\n        deck = deck.filter(x => [ cardLeft, cardRight ].indexOf(x) === -1)\n        playerCardsLeftPosition.push(cardLeft[ 0 ])\n        playerCardsRightPosition.push(cardRight[ 0 ])\n        const historyItem = appendEpoch({\n          ...action,\n          payload: { bet: initialBet },\n          left: playerCardsLeftPosition,\n          right: playerCardsRightPosition\n        })\n        let left = this.enforceRules(engine.getHandInfoAfterSplit(playerCardsLeftPosition, dealerCards, initialBet))\n        let right = this.enforceRules(engine.getHandInfoAfterSplit(playerCardsRightPosition, dealerCards, initialBet))\n        let stage = ''\n        if (forceShowdown) {\n          stage = TYPES.STAGE_SHOWDOWN\n          left.close = true\n          right.close = true\n        } else {\n          if (right.close) {\n            stage = TYPES.STAGE_PLAYER_TURN_LEFT\n          } else {\n            stage = TYPES.STAGE_PLAYER_TURN_RIGHT\n          }\n        }\n        if (right.close && left.close) {\n          stage = TYPES.STAGE_SHOWDOWN\n        }\n        this.setState({\n          stage: stage,\n          handInfo: {\n            left,\n            right\n          },\n          deck: deck,\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        if (stage === TYPES.STAGE_SHOWDOWN) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.HIT: {\n        let stage = ''\n        const { initialBet, deck, handInfo, dealerCards, cardCount, history, hits } = this.state\n        const position = action.payload.position\n        const card = deck.splice(deck.length - 1, 1)\n        let playerCards = []\n        let left = {}\n        let right = {}\n        const hasSplit = history.some(x => x.type === TYPES.SPLIT)\n        if (position === TYPES.LEFT) {\n          playerCards = handInfo.left.cards.concat(card)\n          left = engine.getHandInfoAfterHit(playerCards, dealerCards, initialBet, hasSplit)\n          right = Object.assign({}, handInfo.right)\n          if (left.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          } else {\n            stage = `player-turn-${position}`\n          }\n        } else {\n          playerCards = handInfo.right.cards.concat(card)\n          right = engine.getHandInfoAfterHit(playerCards, dealerCards, initialBet, hasSplit)\n          left = Object.assign({}, handInfo.left)\n          if (right.close) {\n            if (history.some(x => x.type === TYPES.SPLIT)) {\n              stage = TYPES.STAGE_PLAYER_TURN_LEFT\n            } else {\n              stage = TYPES.STAGE_SHOWDOWN\n            }\n          } else {\n            stage = `player-turn-${position}`\n          }\n          if (right.close && left.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          }\n        }\n        const objCards = {}\n        objCards[position] = playerCards\n        const historyItem = appendEpoch({\n          ...action,\n          ...objCards\n        })\n        this.setState({\n          stage: stage,\n          handInfo: { left, right },\n          deck: deck.filter(x => playerCards.indexOf(x) === -1),\n          cardCount: cardCount + engine.countCards(card),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        if (stage === TYPES.STAGE_SHOWDOWN) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.DOUBLE: {\n        let stage = ''\n        const { initialBet, deck, handInfo, dealerCards, cardCount, history, hits } = this.state\n        const position = action.payload.position\n        const card = deck.splice(deck.length - 1, 1)\n        let playerCards: Array<card> = []\n        let left = {}\n        let right = {}\n        const hasSplit = history.some(x => x.type === TYPES.SPLIT)\n        // TODO: remove position and replace it with stage info #hit\n        if (position === TYPES.LEFT) {\n          right = Object.assign({}, handInfo.right)\n          playerCards = handInfo.left.cards.concat(card)\n          left = engine.getHandInfoAfterDouble(playerCards, dealerCards, initialBet, hasSplit)\n          if (left.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          } else {\n            stage = `player-turn-${position}`\n          }\n        } else {\n          playerCards = handInfo.right.cards.concat(card)\n          left = Object.assign({}, handInfo.left)\n          right = engine.getHandInfoAfterDouble(playerCards, dealerCards, initialBet, hasSplit)\n          if (right.close) {\n            if (history.some(x => x.type === TYPES.SPLIT)) {\n              stage = TYPES.STAGE_PLAYER_TURN_LEFT\n            } else {\n              stage = TYPES.STAGE_SHOWDOWN\n            }\n          } else {\n            stage = `player-turn-${position}`\n          }\n        }\n        const objCards = {}\n        objCards[position] = playerCards\n        const historyItem = appendEpoch({\n          ...action,\n          payload: { bet: initialBet },\n          ...objCards\n        })\n        this.setState({\n          stage: stage,\n          handInfo: { left, right },\n          deck: deck.filter(x => playerCards.indexOf(x) === -1),\n          cardCount: cardCount + engine.countCards(card),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        this._dispatch(actions.stand(position))\n        break\n      }\n      case TYPES.STAND: {\n        let stage = ''\n        const { handInfo, history, hits } = this.state\n        const position = action.payload.position\n        let left = {}\n        let right = {}\n        const hasSplit = history.some(x => x.type === TYPES.SPLIT)\n        if (position === TYPES.LEFT) {\n          right = Object.assign({}, handInfo.right)\n          left = engine.getHandInfoAfterStand(handInfo.left)\n          stage = TYPES.STAGE_SHOWDOWN\n        }\n        if (position === TYPES.RIGHT) {\n          left = Object.assign({}, handInfo.left)\n          right = engine.getHandInfoAfterStand(handInfo.right)\n          if (right.close) {\n            stage = TYPES.STAGE_SHOWDOWN\n          }\n        }\n        if (hasSplit) {\n          stage = stage !== TYPES.STAGE_SHOWDOWN ? TYPES.STAGE_PLAYER_TURN_LEFT : TYPES.STAGE_SHOWDOWN\n        }\n        if (hasSplit && !left.close) {\n          stage = TYPES.STAGE_PLAYER_TURN_LEFT\n        }\n        const historyItem = appendEpoch(action)\n        this.setState({\n          stage,\n          handInfo: { left, right },\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        if (stage === TYPES.STAGE_SHOWDOWN) {\n          this._dispatch(actions.showdown())\n        }\n        break\n      }\n      case TYPES.SHOWDOWN: {\n        const { dealerHoleCard, handInfo, history, hits } = this.state\n        const { dealerHoleCardOnly } = action.payload\n        const historyItem = appendEpoch(action)\n        this.setState({\n          stage: TYPES.STAGE_DEALER_TURN,\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        // we want to include in the calculation the dealerHoleCard obtained in initial deal()\n        this._dispatch(actions.dealerHit({ dealerHoleCard: dealerHoleCard }))\n        if (dealerHoleCardOnly) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        const checkLeftStatus = history.some(x => x.type === TYPES.SPLIT)\n        const check1 = (handInfo.right.playerHasBusted || handInfo.right.playerHasBlackjack) && !checkLeftStatus\n        if (check1) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        const check2 = checkLeftStatus && (handInfo.left.playerHasBusted || handInfo.left.playerHasBlackjack) && check1\n        if (check2) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        if (checkLeftStatus && handInfo.left.playerHasBusted && handInfo.right.playerHasBusted) {\n          this.setState({\n            stage: TYPES.STAGE_DONE,\n            ...engine.getPrizes(this.state)\n          })\n          break\n        }\n        while (this.getState().stage === TYPES.STAGE_DEALER_TURN) {\n          this._dispatch(actions.dealerHit())\n        }\n        this.setState({\n          ...engine.getPrizes(this.state)\n        })\n        break\n      }\n      case TYPES.SURRENDER: {\n        const { handInfo, history, hits } = this.state\n        handInfo.right = engine.getHandInfoAfterSurrender(handInfo.right)\n        const historyItem = appendEpoch(action)\n        this.setState({\n          stage: TYPES.STAGE_SHOWDOWN,\n          handInfo: handInfo,\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        this._dispatch(actions.showdown({ dealerHoleCardOnly: true }))\n        break\n      }\n      case TYPES.DEALER_HIT: {\n        const { rules, deck, cardCount, history, hits } = this.state\n        // the new card for dealer can be the \"dealerHoleCard\" or a new card\n        // dealerHoleCard was set at the deal()\n        const { dealerHoleCard } = action.payload\n        const card = dealerHoleCard || deck.splice(deck.length - 1, 1)[ 0 ]\n        const dealerCards = this.state.dealerCards.concat([card])\n        const dealerValue = engine.calculate(dealerCards)\n        const dealerHasBlackjack = engine.isBlackjack(dealerCards)\n        const dealerHasBusted = dealerValue.hi > 21\n        let stage = null\n        if (dealerValue.hi < 17) {\n          stage = TYPES.STAGE_DEALER_TURN\n        } else {\n          if (!rules.standOnSoft17 && engine.isSoftHand(dealerCards)) {\n            stage = TYPES.STAGE_DEALER_TURN\n          } else {\n            stage = TYPES.STAGE_DONE\n          }\n        }\n        const historyItem = appendEpoch({\n          ...action,\n          dealerCards\n        })\n        this.setState({\n          stage: stage,\n          dealerCards: dealerCards,\n          dealerValue: dealerValue,\n          dealerHasBlackjack: dealerHasBlackjack,\n          dealerHasBusted: dealerHasBusted,\n          deck: deck.filter(x => dealerCards.indexOf(x) === -1),\n          cardCount: cardCount + engine.countCards([card]),\n          history: history.concat(historyItem),\n          hits: hits + 1\n        })\n        break\n      }\n      default: {\n        const { history, hits } = this.state\n        const historyItem = appendEpoch(action)\n        this.setState({\n          hits: hits + 1,\n          history: history.concat(historyItem)\n        })\n        break\n      }\n    }\n    return this.getState()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/game.js","export default (flatCards, suited, value) => {\n  const key = `${flatCards}${suited ? 's' : ''}`\n  if (key === '777s') {\n    return 200\n  }\n  if (key === '678s') {\n    return 100\n  }\n  if (key === '777') {\n    return 50\n  }\n  if (key === '678') {\n    return 30\n  }\n  if ((value.hi === 21 || value.lo === 21) && suited) {\n    return 10\n  }\n  if ((value.hi === 21 || value.lo === 21) && !suited) {\n    return 3\n  }\n  if ((value.hi === 20 || value.lo === 20)) {\n    return 3\n  }\n  if (value.hi === 19 || value.lo === 19) {\n    return 2\n  }\n  return 0\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/paytables/luchyLuchy.js"],"sourceRoot":""}